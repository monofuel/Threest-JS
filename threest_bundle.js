(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var bail_out, create_word, current_word, exited, line_list, output, peek, peek_r, pop, pop_r, push, push_r, return_lines, return_stack, run_word, stack, threest;

threest = require('./threest');

stack = new Array();

return_stack = new Array();

output = new Array();

exports.output = output;

return_lines = [];

line_list = "";

current_word = 0;

bail_out = false;

exited = false;

exports.exited = exited;

create_word = function() {
  return current_word++;
};

push = function(a) {
  return stack.push(a);
};

pop = function() {
  if (stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return stack.pop();
};

peek = function() {
  if (stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return stack[stack.length - 1];
};

push_r = function(a) {
  return return_stack.push(a);
};

pop_r = function() {
  if (return_stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return return_stack.pop();
};

peek_r = function() {
  if (return_stack.length === 0) {
    console.log("STACK UNDERFLOW");
  }
  return return_stack[return_stack.length - 1];
};

exports.push = push;

exports.pop = pop;

exports.peek = peek;

exports.push_r = push_r;

exports.pop_r = pop_r;

exports.peek_r = peek_r;

run_word = function(word) {
  var choice, content, current_line, element, index, limit, old_current_word;
  console.log(word);
  if (bail_out) {
    return;
  }
  if (return_lines.length > 20) {
    console.log("depth limit exceeded, bailing out");
    bail_out = true;
    return;
  }
  index = 0;
  limit = 0;
  choice = 0;
  element = {};
  switch (word.type) {
    case threest.types["do"]:
      index = pop();
      limit = pop();
      push_r(limit);
      return push_r(index);
    case threest.types.loop:
      index = pop_r();
      limit = pop_r();
      index++;
      if (index >= 2000) {
        console.log("loop limit exceeded, bailing out");
        bail_out = true;
        return;
      }
      if (limit === index) {
        break;
      } else {
        current_word = word.content.do_ptr + 1;
        push_r(limit);
        return push_r(index);
      }
      break;
    case threest.types["if"]:
      choice = pop();
      if (!choice) {
        if (word.content.else_ptr === -1) {
          return current_word = word.content.then_ptr + 1;
        } else {
          return current_word = word.content.else_ptr + 1;
        }
      }
      break;
    case threest.types["else"]:
      return current_word = word.content.then_ptr + 1;
    case threest.types.then:
      break;
    case threest.types.word:
      content = word.content;
      if (content.builtin) {
        return content["function"]();
      } else {
        old_current_word = current_word;
        current_word = 0;
        return_lines.push(current_line);
        current_line = content["function"];
        while (current_word < current_line.length) {
          run_word(current_line[current_word]);
          current_word++;
        }
        current_word = old_current_word;
        return current_line = return_lines.pop();
      }
      break;
    case threest.types.int:
      return push(word.content);
  }
};

exports.get_line = function() {
  return current_line;
};

exports.get_current_word = function() {
  return current_word;
};

exports.set_current_word = function(index) {
  return current_word = index;
};

exports.parse_line = function(line) {
  var crate, word;
  bail_out = false;
  output = new Array();
  exports.output = output;
  if (line === "") {
    return;
  }
  line_list = line.split(" ");
  exports.get_line = function() {
    return line_list;
  };
  current_word = 0;
  while (current_word < line_list.length) {
    word = line_list[current_word];
    if (word === '(') {
      while (true) {
        if (line_list[++current_word] >= line_list.length) {
          output.push("unfinished comment: " + line);
          return;
        }
        if (line_list[current_word].endsWith(')')) {
          break;
        }
      }
    }
    if (word === ' ' || word === '\n') {

    } else if (!isNaN(parseInt(word))) {
      crate = new threest.crate(threest.types.int);
      crate.content = parseInt(word);
      run_word(crate);
    } else if (threest.get_word(word) !== void 0) {
      crate = new threest.crate(threest.types.word);
      crate.content = threest.get_word(word);
      run_word(crate);
    } else {
      output.push("word not found");
    }
    current_word++;
  }
  return output.push("OK.");
};

},{"./threest":4}],3:[function(require,module,exports){
/*! terminal.js v2.0 | (c) 2014 Erik Ã–sterberg | https://github.com/eosterberg/terminaljs */

var Terminal = (function () {
	// PROMPT_TYPE
	var PROMPT_INPUT = 1, PROMPT_PASSWORD = 2, PROMPT_CONFIRM = 3

	var fireCursorInterval = function (inputField, terminalObj) {
		var cursor = terminalObj._cursor
		setTimeout(function () {
			if (inputField.parentElement && terminalObj._shouldBlinkCursor) {
				cursor.style.visibility = cursor.style.visibility === 'visible' ? 'hidden' : 'visible'
				fireCursorInterval(inputField, terminalObj)
			} else {
				cursor.style.visibility = 'visible'
			}
		}, 500)
	}

	var firstPrompt = true;
	promptInput = function (terminalObj, message, PROMPT_TYPE, callback) {
		var shouldDisplayInput = (PROMPT_TYPE === PROMPT_INPUT)
		var inputField = document.createElement('input')

		inputField.style.position = 'absolute'
		inputField.style.zIndex = '-100'
		inputField.style.outline = 'none'
		inputField.style.border = 'none'
		inputField.style.opacity = '0'
		inputField.style.fontSize = '0.2em'

		terminalObj._inputLine.textContent = ''
		terminalObj._input.style.display = 'block'
		terminalObj.html.appendChild(inputField)
		fireCursorInterval(inputField, terminalObj)

		if (message.length) terminalObj.print(PROMPT_TYPE === PROMPT_CONFIRM ? message + ' (y/n)' : message)

		inputField.onblur = function () {
			terminalObj._cursor.style.display = 'none'
		}

		inputField.onfocus = function () {
			inputField.value = terminalObj._inputLine.textContent
			terminalObj._cursor.style.display = 'inline'
		}

		terminalObj.html.onclick = function () {
			inputField.focus()
		}

		inputField.onkeydown = function (e) {
			if (e.which === 37 || e.which === 39 || e.which === 38 || e.which === 40 || e.which === 9) {
				e.preventDefault()
			} else if (shouldDisplayInput && e.which !== 13) {
				setTimeout(function () {
					terminalObj._inputLine.textContent = inputField.value
				}, 1)
			}
		}
		inputField.onkeyup = function (e) {
			if (PROMPT_TYPE === PROMPT_CONFIRM || e.which === 13) {
				terminalObj._input.style.display = 'none'
				var inputValue = inputField.value
				if (shouldDisplayInput) terminalObj.print(inputValue)
				terminalObj.html.removeChild(inputField)
				if (typeof(callback) === 'function') {
					if (PROMPT_TYPE === PROMPT_CONFIRM) {
						callback(inputValue.toUpperCase()[0] === 'Y' ? true : false)
					} else callback(inputValue)
				}
			}
		}
		if (firstPrompt) {
			firstPrompt = false
			setTimeout(function () { inputField.focus()	}, 50)
		} else {
			inputField.focus()
		}
	}

	var terminalBeep

	var TerminalConstructor = function (id) {
		if (!terminalBeep) {
			terminalBeep = document.createElement('audio')
			var source = '<source src="http://www.erikosterberg.com/terminaljs/beep.'
			terminalBeep.innerHTML = source + 'mp3" type="audio/mpeg">' + source + 'ogg" type="audio/ogg">'
			terminalBeep.volume = 0.05
		}

		this.html = document.createElement('div')
		this.html.className = 'Terminal'
		if (typeof(id) === 'string') { this.html.id = id }

		this._innerWindow = document.createElement('div')
		this._output = document.createElement('p')
		this._inputLine = document.createElement('span') //the span element where the users input is put
		this._cursor = document.createElement('span')
		this._input = document.createElement('p') //the full element administering the user input, including cursor

		this._shouldBlinkCursor = true

		this.beep = function () {
			terminalBeep.load()
			terminalBeep.play()
		}

		this.print = function (message) {
			var newLine = document.createElement('div')
			newLine.textContent = message
			this._output.appendChild(newLine)
		}

		this.input = function (message, callback) {
			promptInput(this, message, PROMPT_INPUT, callback)
		}

		this.password = function (message, callback) {
			promptInput(this, message, PROMPT_PASSWORD, callback)
		}

		this.confirm = function (message, callback) {
			promptInput(this, message, PROMPT_CONFIRM, callback)
		}

		this.clear = function () {
			this._output.innerHTML = ''
		}

		this.sleep = function (milliseconds, callback) {
			setTimeout(callback, milliseconds)
		}

		this.setTextSize = function (size) {
			this._output.style.fontSize = size
			this._input.style.fontSize = size
		}

		this.setTextColor = function (col) {
			this.html.style.color = col
			this._cursor.style.background = col
		}

		this.setBackgroundColor = function (col) {
			this.html.style.background = col
		}

		this.setWidth = function (width) {
			this.html.style.width = width
		}

		this.setHeight = function (height) {
			this.html.style.height = height
		}

		this.blinkingCursor = function (bool) {
			bool = bool.toString().toUpperCase()
			this._shouldBlinkCursor = (bool === 'TRUE' || bool === '1' || bool === 'YES')
		}

		this._input.appendChild(this._inputLine)
		this._input.appendChild(this._cursor)
		this._innerWindow.appendChild(this._output)
		this._innerWindow.appendChild(this._input)
		this.html.appendChild(this._innerWindow)

		this.setBackgroundColor('black')
		this.setTextColor('white')
		this.setTextSize('1em')
		this.setWidth('100%')
		this.setHeight('100%')

		this.html.style.fontFamily = 'Monaco, Courier'
		this.html.style.margin = '0'
		this._innerWindow.style.padding = '10px'
		this._input.style.margin = '0'
		this._output.style.margin = '0'
		this._cursor.style.background = 'white'
		this._cursor.innerHTML = 'C' //put something in the cursor..
		this._cursor.style.display = 'none' //then hide it
		this._input.style.display = 'none'
	}

	return TerminalConstructor
}())
},{}],4:[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.10.0
var create_word, global_dict, inter;

inter = require('./interpreter');

exports.types = {
  word: 0,
  "if": 1,
  "else": 2,
  then: 3,
  "do": 4,
  loop: 5,
  int: 6,
  float: 7,
  array: 8,
  object: 9,
  string: 10,
  bool: 11
};

exports.word = function(builtin, content) {
  this.builtin = builtin;
  return this["function"] = content;
};

exports.crate = function(type, content) {
  this.type = type;
  return this.content = content;
};

exports._if = function() {
  this.else_ptr = -1;
  return this.then_ptr = -1;
};

exports._else = function() {
  return this.then_ptr = -1;
};

exports._loop = function() {
  return this.do_ptr = -1;
};

global_dict = {
  ":": {
    builtin: true,
    "function": function() {
      return create_word();
    }
  },
  "DUP": {
    builtin: true,
    "function": function() {
      return inter.push(inter.peek());
    }
  },
  "SWAP": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      inter.push(j);
      return inter.push(k);
    }
  },
  ">R": {
    builtin: true,
    "function": function() {
      return inter.push_r(inter.pop());
    }
  },
  "R>": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop_r());
    }
  },
  "I": {
    builtin: true,
    "function": function() {
      return inter.push(inter.peek_r());
    }
  },
  "CR": {
    builtin: true,
    "function": function() {
      return inter.output.push("\n");
    }
  },
  "+": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop() + inter.pop());
    }
  },
  "-": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k - j);
    }
  },
  "/": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k / j);
    }
  },
  "*": {
    builtin: true,
    "function": function() {
      return inter.push(inter.pop() * inter.pop());
    }
  },
  "<": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k < j);
    }
  },
  ">": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k > j);
    }
  },
  "=": {
    builtin: true,
    "function": function() {
      var j, k;
      j = inter.pop();
      k = inter.pop();
      return inter.push(k === j);
    }
  },
  "DROP": {
    builtin: true,
    "function": function() {
      return inter.pop();
    }
  },
  ".": {
    builtin: true,
    "function": function() {
      return inter.output.push(inter.pop());
    }
  },
  "WORDS": {
    builtin: true,
    "function": function() {
      var word_list;
      word_list = "";
      Object.keys(global_dict).forEach(function(word) {
        return word_list += word + " ";
      });
      word_list += "IF ";
      word_list += "ELSE ";
      word_list += "THEN ";
      word_list += "DO ";
      word_list += "LOOP ";
      word_list += "RECURSE";
      return inter.output.push(word_list);
    }
  },
  "BYE": {
    builtin: true,
    "function": function() {
      inter.output.push("CYA");
      inter.exited = true;
      return process.exit(0);
    }
  }
};

exports.get_word = function(word) {
  return global_dict[word];
};

create_word = function() {
  var crate, forward_index, if_count, index, list, loop_count, reverse_index, start_index, word, word_name;
  list = inter.get_line();
  index = inter.get_current_word();
  start_index = index + 3;
  word_name = list[++index];
  word = new exports.word(false);
  word["function"] = new Array();
  index++;
  while (list[index] !== ';') {
    if (!isNaN(parseInt(list[index]))) {
      crate = new exports.crate(exports.types.int, parseInt(list[index]));
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "IF") {
      crate = new exports.crate(exports.types["if"]);
      crate.content = new exports._if();
      forward_index = index;
      if_count = 0;
      while (forward_index < list.length) {
        forward_index++;
        if (list[forward_index] === "IF") {
          if_count++;
        }
        if (list[forward_index] === "THEN") {
          if (if_count === 0) {
            crate.content.then_ptr = forward_index - start_index;
            break;
          } else {
            if_count--;
          }
        }
        if (list[forward_index] === "ELSE") {
          if (if_count === 0) {
            crate.content.else_ptr = forward_index - start_index;
            break;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found IF without matching THEN");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "ELSE") {
      crate = new exports.crate(exports.types["else"]);
      crate.content = new exports._else();
      forward_index = index;
      if_count = 0;
      while (forward_index < list.length) {
        forward_index++;
        if (list[forward_index] === "IF") {
          if_count++;
        }
        if (list[forward_index] === "THEN") {
          if (if_count === 0) {
            crate.content.then_ptr = forward_index - start_index;
            break;
          } else {
            if_count--;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found ELSE without matching THEN");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "THEN") {
      crate = new exports.crate(exports.types.then);
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "DO") {
      crate = new exports.crate(exports.types["do"]);
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "LOOP") {
      crate = new exports.crate(exports.types.loop);
      crate.content = new exports._loop();
      reverse_index = index;
      loop_count = 0;
      while (reverse_index > 0) {
        reverse_index--;
        if (list[reverse_index] === "LOOP") {
          loop_count++;
        }
        if (list[reverse_index] === "DO") {
          if (loop_count === 0) {
            crate.content.do_ptr = reverse_index - start_index;
          } else {
            loop_count--;
          }
        }
      }
      if (forward_index === list.length) {
        inter.output.push("found LOOP without matching DO");
      }
      word["function"].push(crate);
      index++;
      continue;
    }
    if (list[index] === "RECURSE") {
      crate = new exports.crate(exports.types.word, word);
      word["function"].push(crate);
      index++;
      continue;
    }
    if (exports.get_word(list[index]) !== void 0) {
      crate = new exports.crate(exports.types.word);
      crate.content = exports.get_word(list[index]);
      word["function"].push(crate);
      index++;
      continue;
    }
    index++;
  }
  global_dict[word_name] = word;
  return inter.set_current_word(index);
};

}).call(this,require('_process'))
},{"./interpreter":2,"_process":1}],5:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
var inter;

inter = require('./interpreter');

require('./terminal');

document.addEventListener('DOMContentLoaded', function() {
  var repl, threest;
  threest = new Terminal();
  threest.setBackgroundColor("#002b36");
  threest.setTextColor("#586e75");
  threest.print("Welcome to Threest!");
  repl = function() {
    return threest.input(">", function(input) {
      inter.parse_line(input);
      inter.output.forEach(function(o) {
        return threest.print(o);
      });
      if (!inter.exited) {
        return repl();
      }
    });
  };
  repl();
  return termDiv.appendChild(threest.html);
}, false);

},{"./interpreter":2,"./terminal":3}]},{},[5]);
